name: Build and Release

# æ·»åŠ æƒé™é…ç½®ä»¥è§£å†³ Create Release æƒé™é”™è¯¯
permissions:
  contents: write
  packages: write
  actions: read
  security-events: write

on:
  push:
    tags:
      - 'v*'
  pull_request:
    branches: [main, dev]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'draft'
        type: choice
        options:
          - draft
          - prerelease
          - release

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  # å‰ç«¯æ„å»ºå’Œæµ‹è¯•
  frontend-test:
    runs-on: ubuntu-latest
    continue-on-error: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 'latest'
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        continue-on-error: false

      - name: Run TypeScript check
        run: pnpm run type-check
        continue-on-error: false

      - name: Run ESLint
        run: pnpm run lint
        continue-on-error: false

      - name: Check code formatting
        run: pnpm run format:check
        continue-on-error: false

      - name: Build frontend
        run: pnpm run build
        continue-on-error: false

      - name: Upload frontend build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: dist/
          retention-days: 1

  # macOS æ„å»º
  build-macos:
    needs: frontend-test
    runs-on: macos-latest
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        target: [x86_64-apple-darwin, aarch64-apple-darwin]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 'latest'
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache Rust toolchain
        uses: actions/cache@v4
        with:
          path: |
            ~/.rustup
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-rust-toolchain-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-rust-toolchain-
        timeout-minutes: 10
        continue-on-error: true

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'
          key: ${{ matrix.target }}
          cache-targets: true
          cache-on-failure: true

      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        continue-on-error: false

      - name: Download frontend artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: dist/
        continue-on-error: false

      - name: Build Tauri app
        continue-on-error: false
        run: |
          if [ "${{ matrix.target }}" = "x86_64-apple-darwin" ]; then
            pnpm run build:mac-x86
          else
            pnpm run build:mac-aarch
          fi

      - name: Create dist-builds directory if not exists
        run: |
          mkdir -p dist-builds
          ls -la dist-builds/

      - name: Upload macOS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-${{ matrix.target }}
          path: dist-builds/
          retention-days: 3
        if: always()
        continue-on-error: true

  # Windows æ„å»º
  build-windows:
    needs: frontend-test
    runs-on: windows-latest
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        # æ³¨é‡Šæ‰ aarch64-pc-windows-msvc: x86_64 ç‰ˆæœ¬åœ¨ ARM èŠ¯ç‰‡ä¸Šä¹Ÿèƒ½è¿è¡Œ
        target: [x86_64-pc-windows-msvc] # , aarch64-pc-windows-msvc
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 'latest'
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache cargo-xwin
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/cargo-xwin*
            ~/.cargo/.crates.toml
            ~/.cargo/.crates2.json
          key: ${{ runner.os }}-cargo-xwin-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-xwin-
        timeout-minutes: 5
        continue-on-error: true

      - name: Install cargo-xwin (Windows cross-compilation)
        shell: bash
        run: |
          if ! command -v cargo-xwin &> /dev/null; then
            cargo install cargo-xwin
          else
            echo "cargo-xwin already installed"
          fi

      - name: Cache Rust toolchain
        uses: actions/cache@v4
        with:
          path: |
            ~/.rustup
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-rust-toolchain-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-rust-toolchain-
        timeout-minutes: 10
        continue-on-error: true

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'
          key: ${{ matrix.target }}
          cache-targets: true
          cache-on-failure: true

      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        continue-on-error: false

      - name: Download frontend artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: dist/
        continue-on-error: false

      - name: Build Tauri app
        continue-on-error: false
        shell: pwsh
        run: |
          if ("${{ matrix.target }}" -eq "x86_64-pc-windows-msvc") {
            pnpm run build:win-x86
          } elseif ("${{ matrix.target }}" -eq "aarch64-pc-windows-msvc") {
            pnpm run build:win-aarch
          } else {
            Write-Error "Unsupported Windows target: ${{ matrix.target }}"
            exit 1
          }

      - name: Debug - List build artifacts
        shell: pwsh
        run: |
          Write-Host "=== Checking build output directories ==="

          # æ£€æŸ¥ä¸»è¦çš„æ„å»ºç›®å½•
          $targetDir = "src-tauri/target/${{ matrix.target }}"
          if (Test-Path $targetDir) {
            Write-Host "Contents of $targetDir:"
            Get-ChildItem -Path $targetDir -Recurse -Name | Sort-Object
          } else {
            Write-Host "Directory $targetDir does not exist"
          }

          # æ£€æŸ¥ bundle ç›®å½•
          $bundleDir = "$targetDir/release/bundle"
          if (Test-Path $bundleDir) {
            Write-Host "`nContents of $bundleDir:"
            Get-ChildItem -Path $bundleDir -Recurse -Name | Sort-Object
          } else {
            Write-Host "Directory $bundleDir does not exist"
          }

          # æ£€æŸ¥æ˜¯å¦æœ‰ .exe æ–‡ä»¶
          Write-Host "`n=== Looking for .exe files ==="
          Get-ChildItem -Path "src-tauri/target" -Recurse -Filter "*.exe" | ForEach-Object {
            Write-Host "Found: $($_.FullName)"
          }

          # æ£€æŸ¥æ˜¯å¦æœ‰ .msi æ–‡ä»¶
          Write-Host "`n=== Looking for .msi files ==="
          Get-ChildItem -Path "src-tauri/target" -Recurse -Filter "*.msi" | ForEach-Object {
            Write-Host "Found: $($_.FullName)"
          }
        continue-on-error: true

      - name: Create dist-builds directory and copy artifacts
        shell: pwsh
        run: |
          # åˆ›å»ºè¾“å‡ºç›®å½•
          if (-not (Test-Path "dist-builds")) {
            New-Item -ItemType Directory -Path "dist-builds" -Force
          }

          # æŸ¥æ‰¾å¹¶å¤åˆ¶æ„å»ºäº§ç‰©
          $targetDir = "src-tauri/target/${{ matrix.target }}/release"
          $bundleDir = "$targetDir/bundle"

          Write-Host "Searching for build artifacts..."

          # æŸ¥æ‰¾ .exe å®‰è£…ç¨‹åºï¼ˆé€šå¸¸åœ¨ bundle/nsis ç›®å½•ï¼‰
          $nsisDir = "$bundleDir/nsis"
          if (Test-Path $nsisDir) {
            Get-ChildItem -Path $nsisDir -Filter "*.exe" | ForEach-Object {
              $destPath = "dist-builds/$($_.Name)"
              Copy-Item -Path $_.FullName -Destination $destPath -Force
              Write-Host "Copied installer: $($_.Name) -> $destPath"
            }
          }

          # æŸ¥æ‰¾ .msi å®‰è£…ç¨‹åºï¼ˆé€šå¸¸åœ¨ bundle/msi ç›®å½•ï¼‰
          $msiDir = "$bundleDir/msi"
          if (Test-Path $msiDir) {
            Get-ChildItem -Path $msiDir -Filter "*.msi" | ForEach-Object {
              $destPath = "dist-builds/$($_.Name)"
              Copy-Item -Path $_.FullName -Destination $destPath -Force
              Write-Host "Copied installer: $($_.Name) -> $destPath"
            }
          }

          # å¦‚æœæ²¡æœ‰æ‰¾åˆ°å®‰è£…ç¨‹åºï¼Œå°è¯•å¤åˆ¶å¯æ‰§è¡Œæ–‡ä»¶
          if (-not (Get-ChildItem -Path "dist-builds" -ErrorAction SilentlyContinue)) {
            Write-Host "No installers found, looking for executable files..."
            Get-ChildItem -Path $targetDir -Filter "*.exe" | Where-Object { $_.Name -notlike "*-*" } | ForEach-Object {
              $destPath = "dist-builds/$($_.Name)"
              Copy-Item -Path $_.FullName -Destination $destPath -Force
              Write-Host "Copied executable: $($_.Name) -> $destPath"
            }
          }

          # æ˜¾ç¤ºæœ€ç»ˆç»“æœ
          Write-Host "`nFinal contents of dist-builds:"
          if (Test-Path "dist-builds") {
            Get-ChildItem -Path "dist-builds" -Recurse | ForEach-Object {
              Write-Host "  $($_.Name) ($($_.Length) bytes)"
            }
          } else {
            Write-Host "  (empty)"
          }

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-${{ matrix.target }}
          path: dist-builds/
          retention-days: 3
        if: always()
        continue-on-error: true

  # Linux æ„å»º
  build-linux:
    needs: frontend-test
    runs-on: ubuntu-latest
    timeout-minutes: 90
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        target: [x86_64-unknown-linux-gnu]
        # aarch64-unknown-linux-gnu äº¤å‰ç¼–è¯‘ç¯å¢ƒå¤æ‚ï¼Œæš‚æ—¶ç¦ç”¨
        # å‚è€ƒ: https://v1.tauri.app/v1/guides/building/cross-platform/
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 'latest'
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache system dependencies
        uses: actions/cache@v4
        with:
          path: |
            /var/cache/apt
            /var/lib/apt
          key: ${{ runner.os }}-apt-${{ hashFiles('**/.github/workflows/build-and-release.yml') }}
          restore-keys: |
            ${{ runner.os }}-apt-
        timeout-minutes: 5
        continue-on-error: true

      - name: Cache Rust toolchain
        uses: actions/cache@v4
        with:
          path: |
            ~/.rustup
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-rust-toolchain-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-rust-toolchain-
        timeout-minutes: 10
        continue-on-error: true

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf pkg-config libssl-dev

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'
          key: ${{ matrix.target }}
          cache-targets: true
          cache-on-failure: true

      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        continue-on-error: false

      - name: Download frontend artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: dist/
        continue-on-error: false

      - name: Build Tauri app
        continue-on-error: false
        run: pnpm run build:linux-x86

      - name: Debug - List build artifacts
        run: |
          echo "=== Checking build output directories ==="
          
          # æ£€æŸ¥ä¸»è¦çš„æ„å»ºç›®å½•
          TARGET_DIR="src-tauri/target/${{ matrix.target }}"
          if [ -d "$TARGET_DIR" ]; then
            echo "Contents of $TARGET_DIR:"
            find "$TARGET_DIR" -type f | sort
          else
            echo "Directory $TARGET_DIR does not exist"
          fi
          
          # æ£€æŸ¥ bundle ç›®å½•
          BUNDLE_DIR="$TARGET_DIR/release/bundle"
          if [ -d "$BUNDLE_DIR" ]; then
            echo ""
            echo "Contents of $BUNDLE_DIR:"
            find "$BUNDLE_DIR" -type f | sort
          else
            echo "Directory $BUNDLE_DIR does not exist"
          fi
          
          # æ£€æŸ¥æ˜¯å¦æœ‰ Linux åŒ…æ–‡ä»¶
          echo ""
          echo "=== Looking for Linux package files ==="
          find "src-tauri/target" -name "*.deb" -o -name "*.rpm" -o -name "*.AppImage" 2>/dev/null | while read file; do
            echo "Found: $file"
          done
        continue-on-error: true

      - name: Create dist-builds directory and copy artifacts
        run: |
          # åˆ›å»ºè¾“å‡ºç›®å½•
          mkdir -p dist-builds
          
          echo "Searching for Linux build artifacts..."
          
          # æŸ¥æ‰¾å¹¶å¤åˆ¶æ„å»ºäº§ç‰©
          TARGET_DIR="src-tauri/target/${{ matrix.target }}/release/bundle"
          
          # æŸ¥æ‰¾ .deb æ–‡ä»¶
          if [ -d "$TARGET_DIR/deb" ]; then
            find "$TARGET_DIR/deb" -name "*.deb" -exec cp {} dist-builds/ \;
            find "$TARGET_DIR/deb" -name "*.deb" -exec basename {} \; | while read file; do
              echo "Copied DEB package: $file"
            done
          fi
          
          # æŸ¥æ‰¾ .rpm æ–‡ä»¶
          if [ -d "$TARGET_DIR/rpm" ]; then
            find "$TARGET_DIR/rpm" -name "*.rpm" -exec cp {} dist-builds/ \;
            find "$TARGET_DIR/rpm" -name "*.rpm" -exec basename {} \; | while read file; do
              echo "Copied RPM package: $file"
            done
          fi
          
          # æŸ¥æ‰¾ .AppImage æ–‡ä»¶
          if [ -d "$TARGET_DIR/appimage" ]; then
            find "$TARGET_DIR/appimage" -name "*.AppImage" -exec cp {} dist-builds/ \;
            find "$TARGET_DIR/appimage" -name "*.AppImage" -exec basename {} \; | while read file; do
              echo "Copied AppImage: $file"
            done
          fi
          
          # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•åŒ…æ–‡ä»¶ï¼Œå°è¯•æŸ¥æ‰¾å¯æ‰§è¡Œæ–‡ä»¶
          if [ -z "$(ls -A dist-builds 2>/dev/null)" ]; then
            echo "No package files found, looking for executable files..."
            RELEASE_DIR="src-tauri/target/${{ matrix.target }}/release"
            if [ -d "$RELEASE_DIR" ]; then
              find "$RELEASE_DIR" -maxdepth 1 -type f -executable -not -name "*.*" -exec cp {} dist-builds/ \;
              find "$RELEASE_DIR" -maxdepth 1 -type f -executable -not -name "*.*" -exec basename {} \; | while read file; do
                echo "Copied executable: $file"
              done
            fi
          fi
          
          # æ˜¾ç¤ºæœ€ç»ˆç»“æœ
          echo ""
          echo "Final contents of dist-builds:"
          if [ -d "dist-builds" ] && [ "$(ls -A dist-builds)" ]; then
            ls -la dist-builds/
          else
            echo "  (empty)"
          fi

      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-x86_64
          path: dist-builds/
          retention-days: 3
        if: always()
        continue-on-error: true

  # åˆ›å»º Release
  create-release:
    needs: [build-macos, build-windows, build-linux]
    runs-on: ubuntu-latest
    if: always() && (startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch')
    outputs:
      release_id: ${{ steps.create_release.outputs.id }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get version from tag
        id: get_version
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
          else
            VERSION=$(date +%Y%m%d-%H%M%S)
          fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
        continue-on-error: true

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name || format('v{0}', steps.get_version.outputs.VERSION) }}
          release_name: Release ${{ steps.get_version.outputs.VERSION }}
          body: |
            ## ğŸš€ Release ${{ steps.get_version.outputs.VERSION }}

            ### ğŸ“¦ ä¸‹è½½é“¾æ¥

            #### æ¡Œé¢ç‰ˆæœ¬
            - **macOS**: æ”¯æŒ Intel (x86_64) å’Œ Apple Silicon (ARM64)
            - **Windows**: æ”¯æŒ x86_64 (å…¼å®¹ ARM64 èŠ¯ç‰‡)
            - **Linux**: æ”¯æŒ x86_64 å’Œ ARM64 åŸç”Ÿç‰ˆæœ¬ (AppImage, DEB, RPM)

            > **æ³¨æ„**: Windows çš„ x86_64 ç‰ˆæœ¬å¯ä»¥åœ¨ ARM64 èŠ¯ç‰‡ä¸Šè¿è¡Œã€‚Linux ç°åœ¨æä¾› ARM64 åŸç”Ÿç‰ˆæœ¬ä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½ã€‚



            ### ğŸ”§ å®‰è£…è¯´æ˜

            #### macOS
            1. ä¸‹è½½å¯¹åº”æ¶æ„çš„ `.dmg` æ–‡ä»¶
            2. åŒå‡»æ‰“å¼€å¹¶æ‹–æ‹½åˆ°åº”ç”¨ç¨‹åºæ–‡ä»¶å¤¹
            3. é¦–æ¬¡è¿è¡Œå¯èƒ½éœ€è¦åœ¨ç³»ç»Ÿåå¥½è®¾ç½®ä¸­å…è®¸

            #### Windows
            1. ä¸‹è½½å¯¹åº”æ¶æ„çš„ `.exe` å®‰è£…ç¨‹åº
            2. è¿è¡Œå®‰è£…ç¨‹åºå¹¶æŒ‰æç¤ºæ“ä½œ
            3. Windows Defender å¯èƒ½ä¼šæ˜¾ç¤ºè­¦å‘Šï¼Œé€‰æ‹©"ä»è¦è¿è¡Œ"

            #### Linux
            - **AppImage**: ä¸‹è½½åæ·»åŠ æ‰§è¡Œæƒé™ `chmod +x *.AppImage`
            - **DEB**: ä½¿ç”¨ `sudo dpkg -i *.deb` å®‰è£…
            - **RPM**: ä½¿ç”¨ `sudo rpm -i *.rpm` å®‰è£…



            ---

            **å®Œæ•´æ›´æ–°æ—¥å¿—**: [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md)
          draft: ${{ github.event.inputs.release_type == 'draft' || github.event_name != 'workflow_dispatch' }}
          prerelease: ${{ github.event.inputs.release_type == 'prerelease' }}

  # ä¸Šä¼ æ„å»ºäº§ç‰©åˆ° Release
  upload-release-assets:
    needs: [create-release, build-macos, build-windows, build-linux]
    runs-on: ubuntu-latest
    if: always() && needs.create-release.result == 'success'
    strategy:
      fail-fast: false
      matrix:
        include:
          - artifact: macos-x86_64-apple-darwin
            pattern: '*.dmg'
            name: 'macOS-Intel'
            build_job: 'build-macos'
          - artifact: macos-aarch64-apple-darwin
            pattern: '*.dmg'
            name: 'macOS-AppleSilicon'
            build_job: 'build-macos'
          - artifact: windows-x86_64-pc-windows-msvc
            pattern: '*.exe'
            name: 'Windows-x64'
            build_job: 'build-windows'
          # æ³¨é‡Šæ‰ ARM æ¶æ„ç‰ˆæœ¬: x86_64 ç‰ˆæœ¬åœ¨ ARM èŠ¯ç‰‡ä¸Šä¹Ÿèƒ½è¿è¡Œ
          # - artifact: windows-aarch64-pc-windows-msvc
          #   pattern: '*.exe'
          #   name: 'Windows-ARM64'
          #   build_job: 'build-windows'
          - artifact: linux-x86_64
            pattern: '*.{AppImage,deb,rpm}'
            name: 'Linux-x64'
            build_job: 'build-linux'
    steps:
      - name: Check if build succeeded
        id: check_build
        run: |
          echo "Checking build status for ${{ matrix.build_job }}..."
          echo "Build result: ${{ needs[matrix.build_job].result }}"
          if [ "${{ needs[matrix.build_job].result }}" = "success" ]; then
            echo "build_success=true" >> $GITHUB_OUTPUT
            echo "âœ… Build job ${{ matrix.build_job }} succeeded, proceeding with artifact upload for ${{ matrix.artifact }}"
          else
            echo "build_success=false" >> $GITHUB_OUTPUT
            echo "âŒ Build job ${{ matrix.build_job }} did not succeed (result: ${{ needs[matrix.build_job].result }}), skipping artifact upload for ${{ matrix.artifact }}"
          fi

      - name: Download artifacts
        if: steps.check_build.outputs.build_success == 'true'
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.artifact }}
          path: ./release-assets/
        continue-on-error: true

      - name: Upload Release Assets
        if: steps.check_build.outputs.build_success == 'true'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const releaseId = '${{ needs.create-release.outputs.release_id }}';
            const artifactPath = './release-assets/';

            // æ£€æŸ¥ç›®å½•æ˜¯å¦å­˜åœ¨
            if (!fs.existsSync(artifactPath)) {
              console.log(`Artifact path ${artifactPath} does not exist, skipping upload`);
              return;
            }

            // è·å–ç›®å½•ä¸­çš„æ‰€æœ‰æ–‡ä»¶
            const allFiles = fs.readdirSync(artifactPath);
            console.log(`Found files in ${artifactPath}:`, allFiles);

            // æ ¹æ®ä¸åŒçš„æ¨¡å¼åŒ¹é…æ–‡ä»¶
            let matchedFiles = [];
            const pattern = '${{ matrix.pattern }}';

            if (pattern === '*.dmg') {
              matchedFiles = allFiles.filter(file => file.endsWith('.dmg'));
            } else if (pattern === '*.exe') {
              matchedFiles = allFiles.filter(file => file.endsWith('.exe'));
            } else if (pattern === '*.{AppImage,deb,rpm}') {
              matchedFiles = allFiles.filter(file =>
                file.endsWith('.AppImage') || file.endsWith('.deb') || file.endsWith('.rpm')
              );
            } else {
              // é€šç”¨åŒ¹é…é€»è¾‘
              matchedFiles = allFiles.filter(file => {
                const ext = path.extname(file).toLowerCase();
                return pattern.includes(ext.substring(1)) || pattern.includes('*');
              });
            }

            if (matchedFiles.length === 0) {
              console.log(`No files found matching pattern '${pattern}' in ${artifactPath}`);
              console.log('Available files:', allFiles);
              return;
            }

            console.log(`Found ${matchedFiles.length} matching files:`, matchedFiles);

            for (const file of matchedFiles) {
              const filePath = path.join(artifactPath, file);
              const fileName = path.basename(file);
              const fileData = fs.readFileSync(filePath);

              // ç”Ÿæˆå¸¦å¹³å°æ ‡è¯†çš„æ–‡ä»¶å
              const ext = path.extname(fileName);
              const baseName = path.basename(fileName, ext);
              const newFileName = `${baseName}-${{ matrix.name }}${ext}`;

              console.log(`Uploading ${newFileName} (${fileData.length} bytes)...`);

              try {
                await github.rest.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: releaseId,
                  name: newFileName,
                  data: fileData,
                });
                console.log(`Successfully uploaded ${newFileName}`);
              } catch (error) {
                console.error(`Failed to upload ${newFileName}:`, error.message);
                throw error;
              }
            }

  # æ„å»ºçŠ¶æ€æ€»ç»“
  build-summary:
    needs:
      [
        frontend-test,
        build-macos,
        build-windows,
        build-linux,
        create-release,
        upload-release-assets,
      ]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Build Summary
        run: |
          echo "## ğŸ—ï¸ æ„å»ºçŠ¶æ€æ€»ç»“"
          echo "| ä»»åŠ¡ | çŠ¶æ€ |"
          echo "|------|------|"
          echo "| å‰ç«¯æµ‹è¯• | ${{ needs.frontend-test.result == 'success' && 'âœ… æˆåŠŸ' || 'âŒ å¤±è´¥' }} |"
          echo "| macOS æ„å»º | ${{ needs.build-macos.result == 'success' && 'âœ… æˆåŠŸ' || (needs.build-macos.result == 'failure' && 'âŒ å¤±è´¥' || 'â­ï¸ è·³è¿‡') }} |"
          echo "| Windows æ„å»º | ${{ needs.build-windows.result == 'success' && 'âœ… æˆåŠŸ' || (needs.build-windows.result == 'failure' && 'âŒ å¤±è´¥' || 'â­ï¸ è·³è¿‡') }} |"
          echo "| Linux æ„å»º | ${{ needs.build-linux.result == 'success' && 'âœ… æˆåŠŸ' || (needs.build-linux.result == 'failure' && 'âŒ å¤±è´¥' || 'â­ï¸ è·³è¿‡') }} |"
          echo "| åˆ›å»º Release | ${{ needs.create-release.result == 'success' && 'âœ… æˆåŠŸ' || (needs.create-release.result == 'failure' && 'âŒ å¤±è´¥' || 'â­ï¸ è·³è¿‡') }} |"
          echo "| ä¸Šä¼ èµ„æº | ${{ needs.upload-release-assets.result == 'success' && 'âœ… æˆåŠŸ' || (needs.upload-release-assets.result == 'failure' && 'âŒ å¤±è´¥' || 'â­ï¸ è·³è¿‡') }} |"
          echo ""
          echo "### ğŸ“Š è¯¦ç»†ä¿¡æ¯"
          echo "- å‰ç«¯æµ‹è¯•ç»“æœ: ${{ needs.frontend-test.result }}"
          echo "- macOS æ„å»ºç»“æœ: ${{ needs.build-macos.result }}"
          echo "- Windows æ„å»ºç»“æœ: ${{ needs.build-windows.result }}"
          echo "- Linux æ„å»ºç»“æœ: ${{ needs.build-linux.result }}"
          echo "- Release åˆ›å»ºç»“æœ: ${{ needs.create-release.result }}"
          echo "- èµ„æºä¸Šä¼ ç»“æœ: ${{ needs.upload-release-assets.result }}"

  # æ¸…ç†å·¥ä½œæµäº§ç‰©
  cleanup:
    needs: [build-summary]
    runs-on: ubuntu-latest
    if: always() && (startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch')
    steps:
      - name: Delete workflow artifacts
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: context.runId,
              });

              console.log(`Found ${artifacts.data.artifacts.length} artifacts to clean up`);

              for (const artifact of artifacts.data.artifacts) {
                try {
                  console.log(`Deleting artifact: ${artifact.name}`);
                  await github.rest.actions.deleteArtifact({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    artifact_id: artifact.id,
                  });
                  console.log(`âœ… Successfully deleted: ${artifact.name}`);
                } catch (error) {
                  console.log(`âŒ Failed to delete ${artifact.name}: ${error.message}`);
                }
              }
              console.log('ğŸ§¹ Cleanup completed');
            } catch (error) {
              console.log(`âŒ Cleanup failed: ${error.message}`);
            }
