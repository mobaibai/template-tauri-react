name: Build and Release

# 添加权限配置以解决 Create Release 权限错误
permissions:
  contents: write
  packages: write
  actions: read
  security-events: write

on:
  push:
    tags:
      - 'v*'
  pull_request:
    branches: [main, dev]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'draft'
        type: choice
        options:
          - draft
          - prerelease
          - release

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  # 前端构建和测试
  frontend-test:
    runs-on: ubuntu-latest
    continue-on-error: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 'latest'
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        continue-on-error: false

      - name: Run TypeScript check
        run: pnpm run type-check
        continue-on-error: false

      - name: Run ESLint
        run: pnpm run lint
        continue-on-error: false

      - name: Check code formatting
        run: pnpm run format:check
        continue-on-error: false

      - name: Build frontend
        run: pnpm run build
        continue-on-error: false

      - name: Upload frontend build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: dist/
          retention-days: 1

  # macOS 构建
  build-macos:
    needs: frontend-test
    runs-on: macos-latest
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        target: [x86_64-apple-darwin, aarch64-apple-darwin]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 'latest'
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache Rust toolchain
        uses: actions/cache@v4
        with:
          path: |
            ~/.rustup
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-rust-toolchain-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-rust-toolchain-
        timeout-minutes: 10
        continue-on-error: true

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'
          key: ${{ matrix.target }}
          cache-targets: true
          cache-on-failure: true

      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        continue-on-error: false

      - name: Download frontend artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: dist/
        continue-on-error: false

      - name: Build Tauri app
        continue-on-error: false
        run: |
          if [ "${{ matrix.target }}" = "x86_64-apple-darwin" ]; then
            pnpm run build:mac-x86
          else
            pnpm run build:mac-aarch
          fi

      - name: Create dist-builds directory if not exists
        run: |
          mkdir -p dist-builds
          ls -la dist-builds/

      - name: Upload macOS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-${{ matrix.target }}
          path: dist-builds/
          retention-days: 3
        if: always()
        continue-on-error: true

  # Windows 构建
  build-windows:
    needs: frontend-test
    runs-on: windows-latest
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        # 注释掉 aarch64-pc-windows-msvc: x86_64 版本在 ARM 芯片上也能运行
        target: [x86_64-pc-windows-msvc] # , aarch64-pc-windows-msvc
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 'latest'
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache cargo-xwin
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/cargo-xwin*
            ~/.cargo/.crates.toml
            ~/.cargo/.crates2.json
          key: ${{ runner.os }}-cargo-xwin-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-xwin-
        timeout-minutes: 5
        continue-on-error: true

      - name: Install cargo-xwin (Windows cross-compilation)
        shell: bash
        run: |
          if ! command -v cargo-xwin &> /dev/null; then
            cargo install cargo-xwin
          else
            echo "cargo-xwin already installed"
          fi

      - name: Cache Rust toolchain
        uses: actions/cache@v4
        with:
          path: |
            ~/.rustup
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-rust-toolchain-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-rust-toolchain-
        timeout-minutes: 10
        continue-on-error: true

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'
          key: ${{ matrix.target }}
          cache-targets: true
          cache-on-failure: true

      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        continue-on-error: false

      - name: Download frontend artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: dist/
        continue-on-error: false

      - name: Build Tauri app
        continue-on-error: false
        shell: pwsh
        run: |
          if ("${{ matrix.target }}" -eq "x86_64-pc-windows-msvc") {
            pnpm run build:win-x86
          } elseif ("${{ matrix.target }}" -eq "aarch64-pc-windows-msvc") {
            pnpm run build:win-aarch
          } else {
            Write-Error "Unsupported Windows target: ${{ matrix.target }}"
            exit 1
          }

      - name: Debug - List build artifacts
        shell: pwsh
        run: |
          Write-Host "=== Checking build output directories ==="

          # 检查主要的构建目录
          $targetDir = "src-tauri/target/${{ matrix.target }}"
          if (Test-Path $targetDir) {
            Write-Host "Contents of $targetDir:"
            Get-ChildItem -Path $targetDir -Recurse -Name | Sort-Object
          } else {
            Write-Host "Directory $targetDir does not exist"
          }

          # 检查 bundle 目录
          $bundleDir = "$targetDir/release/bundle"
          if (Test-Path $bundleDir) {
            Write-Host "`nContents of $bundleDir:"
            Get-ChildItem -Path $bundleDir -Recurse -Name | Sort-Object
          } else {
            Write-Host "Directory $bundleDir does not exist"
          }

          # 检查是否有 .exe 文件
          Write-Host "`n=== Looking for .exe files ==="
          Get-ChildItem -Path "src-tauri/target" -Recurse -Filter "*.exe" | ForEach-Object {
            Write-Host "Found: $($_.FullName)"
          }

          # 检查是否有 .msi 文件
          Write-Host "`n=== Looking for .msi files ==="
          Get-ChildItem -Path "src-tauri/target" -Recurse -Filter "*.msi" | ForEach-Object {
            Write-Host "Found: $($_.FullName)"
          }
        continue-on-error: true

      - name: Create dist-builds directory and copy artifacts
        shell: pwsh
        run: |
          # 创建输出目录
          if (-not (Test-Path "dist-builds")) {
            New-Item -ItemType Directory -Path "dist-builds" -Force
          }

          # 查找并复制构建产物
          $targetDir = "src-tauri/target/${{ matrix.target }}/release"
          $bundleDir = "$targetDir/bundle"

          Write-Host "Searching for build artifacts..."

          # 查找 .exe 安装程序（通常在 bundle/nsis 目录）
          $nsisDir = "$bundleDir/nsis"
          if (Test-Path $nsisDir) {
            Get-ChildItem -Path $nsisDir -Filter "*.exe" | ForEach-Object {
              $destPath = "dist-builds/$($_.Name)"
              Copy-Item -Path $_.FullName -Destination $destPath -Force
              Write-Host "Copied installer: $($_.Name) -> $destPath"
            }
          }

          # 查找 .msi 安装程序（通常在 bundle/msi 目录）
          $msiDir = "$bundleDir/msi"
          if (Test-Path $msiDir) {
            Get-ChildItem -Path $msiDir -Filter "*.msi" | ForEach-Object {
              $destPath = "dist-builds/$($_.Name)"
              Copy-Item -Path $_.FullName -Destination $destPath -Force
              Write-Host "Copied installer: $($_.Name) -> $destPath"
            }
          }

          # 如果没有找到安装程序，尝试复制可执行文件
          if (-not (Get-ChildItem -Path "dist-builds" -ErrorAction SilentlyContinue)) {
            Write-Host "No installers found, looking for executable files..."
            Get-ChildItem -Path $targetDir -Filter "*.exe" | Where-Object { $_.Name -notlike "*-*" } | ForEach-Object {
              $destPath = "dist-builds/$($_.Name)"
              Copy-Item -Path $_.FullName -Destination $destPath -Force
              Write-Host "Copied executable: $($_.Name) -> $destPath"
            }
          }

          # 显示最终结果
          Write-Host "`nFinal contents of dist-builds:"
          if (Test-Path "dist-builds") {
            Get-ChildItem -Path "dist-builds" -Recurse | ForEach-Object {
              Write-Host "  $($_.Name) ($($_.Length) bytes)"
            }
          } else {
            Write-Host "  (empty)"
          }

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-${{ matrix.target }}
          path: dist-builds/
          retention-days: 3
        if: always()
        continue-on-error: true

  # Linux 构建
  build-linux:
    needs: frontend-test
    runs-on: ubuntu-latest
    timeout-minutes: 90
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        target: [x86_64-unknown-linux-gnu]
        # aarch64-unknown-linux-gnu 交叉编译环境复杂，暂时禁用
        # 参考: https://v1.tauri.app/v1/guides/building/cross-platform/
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 'latest'
          run_install: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'pnpm'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Cache system dependencies
        uses: actions/cache@v4
        with:
          path: |
            /var/cache/apt
            /var/lib/apt
          key: ${{ runner.os }}-apt-${{ hashFiles('**/.github/workflows/build-and-release.yml') }}
          restore-keys: |
            ${{ runner.os }}-apt-
        timeout-minutes: 5
        continue-on-error: true

      - name: Cache Rust toolchain
        uses: actions/cache@v4
        with:
          path: |
            ~/.rustup
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-rust-toolchain-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-rust-toolchain-
        timeout-minutes: 10
        continue-on-error: true

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf pkg-config libssl-dev

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'
          key: ${{ matrix.target }}
          cache-targets: true
          cache-on-failure: true

      - name: Install dependencies
        run: pnpm install --frozen-lockfile
        continue-on-error: false

      - name: Download frontend artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: dist/
        continue-on-error: false

      - name: Build Tauri app
        continue-on-error: false
        run: pnpm run build:linux-x86

      - name: Debug - List build artifacts
        run: |
          echo "=== Checking build output directories ==="
          
          # 检查主要的构建目录
          TARGET_DIR="src-tauri/target/${{ matrix.target }}"
          if [ -d "$TARGET_DIR" ]; then
            echo "Contents of $TARGET_DIR:"
            find "$TARGET_DIR" -type f | sort
          else
            echo "Directory $TARGET_DIR does not exist"
          fi
          
          # 检查 bundle 目录
          BUNDLE_DIR="$TARGET_DIR/release/bundle"
          if [ -d "$BUNDLE_DIR" ]; then
            echo ""
            echo "Contents of $BUNDLE_DIR:"
            find "$BUNDLE_DIR" -type f | sort
          else
            echo "Directory $BUNDLE_DIR does not exist"
          fi
          
          # 检查是否有 Linux 包文件
          echo ""
          echo "=== Looking for Linux package files ==="
          find "src-tauri/target" -name "*.deb" -o -name "*.rpm" -o -name "*.AppImage" 2>/dev/null | while read file; do
            echo "Found: $file"
          done
        continue-on-error: true

      - name: Create dist-builds directory and copy artifacts
        run: |
          # 创建输出目录
          mkdir -p dist-builds
          
          echo "Searching for Linux build artifacts..."
          
          # 查找并复制构建产物
          TARGET_DIR="src-tauri/target/${{ matrix.target }}/release/bundle"
          
          # 查找 .deb 文件
          if [ -d "$TARGET_DIR/deb" ]; then
            find "$TARGET_DIR/deb" -name "*.deb" -exec cp {} dist-builds/ \;
            find "$TARGET_DIR/deb" -name "*.deb" -exec basename {} \; | while read file; do
              echo "Copied DEB package: $file"
            done
          fi
          
          # 查找 .rpm 文件
          if [ -d "$TARGET_DIR/rpm" ]; then
            find "$TARGET_DIR/rpm" -name "*.rpm" -exec cp {} dist-builds/ \;
            find "$TARGET_DIR/rpm" -name "*.rpm" -exec basename {} \; | while read file; do
              echo "Copied RPM package: $file"
            done
          fi
          
          # 查找 .AppImage 文件
          if [ -d "$TARGET_DIR/appimage" ]; then
            find "$TARGET_DIR/appimage" -name "*.AppImage" -exec cp {} dist-builds/ \;
            find "$TARGET_DIR/appimage" -name "*.AppImage" -exec basename {} \; | while read file; do
              echo "Copied AppImage: $file"
            done
          fi
          
          # 如果没有找到任何包文件，尝试查找可执行文件
          if [ -z "$(ls -A dist-builds 2>/dev/null)" ]; then
            echo "No package files found, looking for executable files..."
            RELEASE_DIR="src-tauri/target/${{ matrix.target }}/release"
            if [ -d "$RELEASE_DIR" ]; then
              find "$RELEASE_DIR" -maxdepth 1 -type f -executable -not -name "*.*" -exec cp {} dist-builds/ \;
              find "$RELEASE_DIR" -maxdepth 1 -type f -executable -not -name "*.*" -exec basename {} \; | while read file; do
                echo "Copied executable: $file"
              done
            fi
          fi
          
          # 显示最终结果
          echo ""
          echo "Final contents of dist-builds:"
          if [ -d "dist-builds" ] && [ "$(ls -A dist-builds)" ]; then
            ls -la dist-builds/
          else
            echo "  (empty)"
          fi

      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-x86_64
          path: dist-builds/
          retention-days: 3
        if: always()
        continue-on-error: true

  # 创建 Release
  create-release:
    needs: [build-macos, build-windows, build-linux]
    runs-on: ubuntu-latest
    if: always() && (startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch')
    outputs:
      release_id: ${{ steps.create_release.outputs.id }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get version from tag
        id: get_version
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
          else
            VERSION=$(date +%Y%m%d-%H%M%S)
          fi
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
        continue-on-error: true

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name || format('v{0}', steps.get_version.outputs.VERSION) }}
          release_name: Release ${{ steps.get_version.outputs.VERSION }}
          body: |
            ## 🚀 Release ${{ steps.get_version.outputs.VERSION }}

            ### 📦 下载链接

            #### 桌面版本
            - **macOS**: 支持 Intel (x86_64) 和 Apple Silicon (ARM64)
            - **Windows**: 支持 x86_64 (兼容 ARM64 芯片)
            - **Linux**: 支持 x86_64 和 ARM64 原生版本 (AppImage, DEB, RPM)

            > **注意**: Windows 的 x86_64 版本可以在 ARM64 芯片上运行。Linux 现在提供 ARM64 原生版本以获得更好的性能。



            ### 🔧 安装说明

            #### macOS
            1. 下载对应架构的 `.dmg` 文件
            2. 双击打开并拖拽到应用程序文件夹
            3. 首次运行可能需要在系统偏好设置中允许

            #### Windows
            1. 下载对应架构的 `.exe` 安装程序
            2. 运行安装程序并按提示操作
            3. Windows Defender 可能会显示警告，选择"仍要运行"

            #### Linux
            - **AppImage**: 下载后添加执行权限 `chmod +x *.AppImage`
            - **DEB**: 使用 `sudo dpkg -i *.deb` 安装
            - **RPM**: 使用 `sudo rpm -i *.rpm` 安装



            ---

            **完整更新日志**: [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md)
          draft: ${{ github.event.inputs.release_type == 'draft' || github.event_name != 'workflow_dispatch' }}
          prerelease: ${{ github.event.inputs.release_type == 'prerelease' }}

  # 上传构建产物到 Release
  upload-release-assets:
    needs: [create-release, build-macos, build-windows, build-linux]
    runs-on: ubuntu-latest
    if: always() && needs.create-release.result == 'success'
    strategy:
      fail-fast: false
      matrix:
        include:
          - artifact: macos-x86_64-apple-darwin
            pattern: '*.dmg'
            name: 'macOS-Intel'
            build_job: 'build-macos'
          - artifact: macos-aarch64-apple-darwin
            pattern: '*.dmg'
            name: 'macOS-AppleSilicon'
            build_job: 'build-macos'
          - artifact: windows-x86_64-pc-windows-msvc
            pattern: '*.exe'
            name: 'Windows-x64'
            build_job: 'build-windows'
          # 注释掉 ARM 架构版本: x86_64 版本在 ARM 芯片上也能运行
          # - artifact: windows-aarch64-pc-windows-msvc
          #   pattern: '*.exe'
          #   name: 'Windows-ARM64'
          #   build_job: 'build-windows'
          - artifact: linux-x86_64
            pattern: '*.{AppImage,deb,rpm}'
            name: 'Linux-x64'
            build_job: 'build-linux'
    steps:
      - name: Check if build succeeded
        id: check_build
        run: |
          echo "Checking build status for ${{ matrix.build_job }}..."
          echo "Build result: ${{ needs[matrix.build_job].result }}"
          if [ "${{ needs[matrix.build_job].result }}" = "success" ]; then
            echo "build_success=true" >> $GITHUB_OUTPUT
            echo "✅ Build job ${{ matrix.build_job }} succeeded, proceeding with artifact upload for ${{ matrix.artifact }}"
          else
            echo "build_success=false" >> $GITHUB_OUTPUT
            echo "❌ Build job ${{ matrix.build_job }} did not succeed (result: ${{ needs[matrix.build_job].result }}), skipping artifact upload for ${{ matrix.artifact }}"
          fi

      - name: Download artifacts
        if: steps.check_build.outputs.build_success == 'true'
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.artifact }}
          path: ./release-assets/
        continue-on-error: true

      - name: Upload Release Assets
        if: steps.check_build.outputs.build_success == 'true'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const releaseId = '${{ needs.create-release.outputs.release_id }}';
            const artifactPath = './release-assets/';

            // 检查目录是否存在
            if (!fs.existsSync(artifactPath)) {
              console.log(`Artifact path ${artifactPath} does not exist, skipping upload`);
              return;
            }

            // 获取目录中的所有文件
            const allFiles = fs.readdirSync(artifactPath);
            console.log(`Found files in ${artifactPath}:`, allFiles);

            // 根据不同的模式匹配文件
            let matchedFiles = [];
            const pattern = '${{ matrix.pattern }}';

            if (pattern === '*.dmg') {
              matchedFiles = allFiles.filter(file => file.endsWith('.dmg'));
            } else if (pattern === '*.exe') {
              matchedFiles = allFiles.filter(file => file.endsWith('.exe'));
            } else if (pattern === '*.{AppImage,deb,rpm}') {
              matchedFiles = allFiles.filter(file =>
                file.endsWith('.AppImage') || file.endsWith('.deb') || file.endsWith('.rpm')
              );
            } else {
              // 通用匹配逻辑
              matchedFiles = allFiles.filter(file => {
                const ext = path.extname(file).toLowerCase();
                return pattern.includes(ext.substring(1)) || pattern.includes('*');
              });
            }

            if (matchedFiles.length === 0) {
              console.log(`No files found matching pattern '${pattern}' in ${artifactPath}`);
              console.log('Available files:', allFiles);
              return;
            }

            console.log(`Found ${matchedFiles.length} matching files:`, matchedFiles);

            for (const file of matchedFiles) {
              const filePath = path.join(artifactPath, file);
              const fileName = path.basename(file);
              const fileData = fs.readFileSync(filePath);

              // 生成带平台标识的文件名
              const ext = path.extname(fileName);
              const baseName = path.basename(fileName, ext);
              const newFileName = `${baseName}-${{ matrix.name }}${ext}`;

              console.log(`Uploading ${newFileName} (${fileData.length} bytes)...`);

              try {
                await github.rest.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: releaseId,
                  name: newFileName,
                  data: fileData,
                });
                console.log(`Successfully uploaded ${newFileName}`);
              } catch (error) {
                console.error(`Failed to upload ${newFileName}:`, error.message);
                throw error;
              }
            }

  # 构建状态总结
  build-summary:
    needs:
      [
        frontend-test,
        build-macos,
        build-windows,
        build-linux,
        create-release,
        upload-release-assets,
      ]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Build Summary
        run: |
          echo "## 🏗️ 构建状态总结"
          echo "| 任务 | 状态 |"
          echo "|------|------|"
          echo "| 前端测试 | ${{ needs.frontend-test.result == 'success' && '✅ 成功' || '❌ 失败' }} |"
          echo "| macOS 构建 | ${{ needs.build-macos.result == 'success' && '✅ 成功' || (needs.build-macos.result == 'failure' && '❌ 失败' || '⏭️ 跳过') }} |"
          echo "| Windows 构建 | ${{ needs.build-windows.result == 'success' && '✅ 成功' || (needs.build-windows.result == 'failure' && '❌ 失败' || '⏭️ 跳过') }} |"
          echo "| Linux 构建 | ${{ needs.build-linux.result == 'success' && '✅ 成功' || (needs.build-linux.result == 'failure' && '❌ 失败' || '⏭️ 跳过') }} |"
          echo "| 创建 Release | ${{ needs.create-release.result == 'success' && '✅ 成功' || (needs.create-release.result == 'failure' && '❌ 失败' || '⏭️ 跳过') }} |"
          echo "| 上传资源 | ${{ needs.upload-release-assets.result == 'success' && '✅ 成功' || (needs.upload-release-assets.result == 'failure' && '❌ 失败' || '⏭️ 跳过') }} |"
          echo ""
          echo "### 📊 详细信息"
          echo "- 前端测试结果: ${{ needs.frontend-test.result }}"
          echo "- macOS 构建结果: ${{ needs.build-macos.result }}"
          echo "- Windows 构建结果: ${{ needs.build-windows.result }}"
          echo "- Linux 构建结果: ${{ needs.build-linux.result }}"
          echo "- Release 创建结果: ${{ needs.create-release.result }}"
          echo "- 资源上传结果: ${{ needs.upload-release-assets.result }}"

  # 清理工作流产物
  cleanup:
    needs: [build-summary]
    runs-on: ubuntu-latest
    if: always() && (startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch')
    steps:
      - name: Delete workflow artifacts
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: context.runId,
              });

              console.log(`Found ${artifacts.data.artifacts.length} artifacts to clean up`);

              for (const artifact of artifacts.data.artifacts) {
                try {
                  console.log(`Deleting artifact: ${artifact.name}`);
                  await github.rest.actions.deleteArtifact({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    artifact_id: artifact.id,
                  });
                  console.log(`✅ Successfully deleted: ${artifact.name}`);
                } catch (error) {
                  console.log(`❌ Failed to delete ${artifact.name}: ${error.message}`);
                }
              }
              console.log('🧹 Cleanup completed');
            } catch (error) {
              console.log(`❌ Cleanup failed: ${error.message}`);
            }
